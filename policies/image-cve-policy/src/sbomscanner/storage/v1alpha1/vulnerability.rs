use std::collections::BTreeMap;

/// CVSS holds Common Vulnerability Scoring System data for a vulnerability.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize, schemars::JsonSchema)]
pub(crate) struct Cvss {
    /// v3_vector string (e.g., "AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H")
    #[serde(rename = "v3vector")]
    pub v3_vector: String,

    // v3_score numerical score
    #[serde(rename = "v3score")]
    pub v3_score: String,
}

impl k8s_openapi::DeepMerge for Cvss {
    fn merge_from(&mut self, other: Self)
    where
        Self: Sized,
    {
        self.v3_vector.merge_from(other.v3_vector);
        self.v3_score.merge_from(other.v3_score);
    }
}

/// VEXStatus represents the status of a vulnerability as declared
/// in a VEX document
#[cfg(not(target_arch = "wasm32"))]
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize, schemars::JsonSchema)]
#[serde(rename_all = "camelCase")]
pub(crate) struct VexStatus {
    /// Repository providing the VEX document
    pub repository: String,

    /// VEX status (e.g., "not_affected", "fixed", "under_investigation")
    pub status: String,

    /// Statement optionally explain statement from the VEX document
    pub statement: String,
}

#[cfg(not(target_arch = "wasm32"))]
impl k8s_openapi::DeepMerge for VexStatus {
    fn merge_from(&mut self, other: Self)
    where
        Self: Sized,
    {
        self.repository.merge_from(other.repository);
        self.status.merge_from(other.status);
        self.statement.merge_from(other.statement);
    }
}

#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize, schemars::JsonSchema)]
#[serde(rename_all = "UPPERCASE")]
pub(crate) enum Severity {
    Critical,
    High,
    Medium,
    Low,
    Unknown,
}

/// Vulnerability contains detailed information about a single vulnerability
/// found in a package
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize, schemars::JsonSchema)]
#[serde(rename_all = "camelCase")]
pub(crate) struct Vulnerability {
    /// CVE identifier
    pub cve: String,

    /// Title is the title of the vulnerability
    #[cfg(not(target_arch = "wasm32"))]
    pub title: Option<String>,

    /// package_name is the name of the vulnerable package
    /// (empty when Class is "binary")
    #[cfg(not(target_arch = "wasm32"))]
    pub package_name: Option<String>,

    /// package_path is the path where the package was found
    /// (equal to Target when Class is "binary").
    /// trivy removes the "/" at the beginning of the path
    /// so we have to restore it.
    #[cfg(not(target_arch = "wasm32"))]
    pub package_path: Option<String>,

    /// PURL (Package URL) identify the package uniquely
    #[cfg(not(target_arch = "wasm32"))]
    pub purl: String,

    /// installed_version of the package that was found
    #[cfg(not(target_arch = "wasm32"))]
    pub installed_version: String,

    /// fixed_versions is the list of versions where the vulnerability is fixed
    pub fixed_versions: Option<Vec<String>>,

    /// diff_id of the image layer where the vulnerability was introduced
    #[cfg(not(target_arch = "wasm32"))]
    #[serde(rename = "diffID")]
    pub diff_id: String,

    /// Description of the vulnerability
    #[cfg(not(target_arch = "wasm32"))]
    pub description: Option<String>,

    /// Severity rating (e.g., "HIGH", "MEDIUM")
    pub severity: Severity,

    /// References contains URLs for more information
    #[cfg(not(target_arch = "wasm32"))]
    pub references: Option<Vec<String>>,

    /// CVSS scoring details
    pub cvss: Option<BTreeMap<String, Cvss>>,

    /// Suppressed identifies when vulnerability has
    /// been suppressed by VEX documents
    pub suppressed: bool,

    /// VEX status information
    #[cfg(not(target_arch = "wasm32"))]
    pub vex_status: Option<VexStatus>,
}

impl Vulnerability {
    /// returns true if the vulnerability has a fix available
    pub fn has_fix(&self) -> bool {
        match &self.fixed_versions {
            Some(fixes) => !fixes.is_empty(),
            None => false,
        }
    }
}

impl k8s_openapi::DeepMerge for Vulnerability {
    fn merge_from(&mut self, other: Self)
    where
        Self: Sized,
    {
        self.cve.merge_from(other.cve);

        cfg_if::cfg_if! {
            if #[cfg(not(target_arch = "wasm32"))] {
                self.title.merge_from(other.title);
                self.package_name.merge_from(other.package_name);
                self.package_path.merge_from(other.package_path);
                self.purl.merge_from(other.purl);
                self.installed_version.merge_from(other.installed_version);
                self.diff_id.merge_from(other.diff_id);
                self.description.merge_from(other.description);
                self.vex_status.merge_from(other.vex_status);
                k8s_openapi::merge_strategies::list::set(&mut self.references, other.references);
            }
        }
        k8s_openapi::merge_strategies::list::set(&mut self.fixed_versions, other.fixed_versions);
        self.severity = other.severity;
        k8s_openapi::merge_strategies::map::granular(
            &mut self.cvss,
            other.cvss,
            |current, other| {
                current.merge_from(other.clone());
            },
        );
        self.suppressed.merge_from(other.suppressed);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn vulnerability() -> Vulnerability {
        let mut cvvs = std::collections::BTreeMap::new();
        cvvs.insert(
            "nvd".to_string(),
            Cvss {
                v3_vector: "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H".to_string(),
                v3_score: "9.1".to_string(),
            },
        );
        cvvs.insert(
            "redhat".to_string(),
            Cvss {
                v3_vector: "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H".to_string(),
                v3_score: "9.1".to_string(),
            },
        );

        Vulnerability{
            cve: "CVE-2021-36159".to_string(),
            title: Some("libfetch: an out of boundary read while libfetch uses strtol to parse the relevant numbers into address bytes leads to information leak or crash".to_string()),
            package_name: Some("apk-tools".to_string()),
            package_path: None,
            purl: "pkg:apk/alpine/apk-tools@2.10.4-r3?arch=armv7&distro=3.11.3".to_string(),
            installed_version: "2.10.4-r3".to_string(),
            fixed_versions: Some(vec!["2.10.7-r0".to_string()]),
            diff_id: "sha256:2f1fbf8a09329e4903e8c8ea1e429cce666ad39f92e2ed39ca02bf5f7db89026".to_string(),
            description: Some("libfetch before 2021-07-26, as used in apk-tools, xbps, and other products, mishandles numeric strings for the FTP and HTTP protocols. The FTP passive mode implementation allows an out-of-bounds read because strtol is used to parse the relevant numbers into address bytes. It does not check if the line ends prematurely. If it does, the for-loop condition checks for the '\\0' terminator one byte too late.".to_string()),
            severity: Severity::Critical,
            references: Some(
                vec![
                    "https://access.redhat.com/security/cve/CVE-2021-36159".to_string(),
                    "https://github.com/freebsd/freebsd-src/commits/main/lib/libfetch".to_string(),
                    "https://gitlab.alpinelinux.org/alpine/apk-tools/-/issues/10749".to_string(),
                    "https://lists.apache.org/thread.html/r61db8e7dcb56dc000a5387a88f7a473bacec5ee01b9ff3f55308aacc%40%3Cdev.kafka.apache.org%3E".to_string(),
                    "https://lists.apache.org/thread.html/r61db8e7dcb56dc000a5387a88f7a473bacec5ee01b9ff3f55308aacc%40%3Cusers.kafka.apache.org%3E".to_string(),
                    "https://lists.apache.org/thread.html/rbf4ce74b0d1fa9810dec50ba3ace0caeea677af7c27a97111c06ccb7%40%3Cdev.kafka.apache.org%3E".to_string(),
                    "https://lists.apache.org/thread.html/rbf4ce74b0d1fa9810dec50ba3ace0caeea677af7c27a97111c06ccb7%40%3Cusers.kafka.apache.org%3E".to_string(),
                    "https://nvd.nist.gov/vuln/detail/CVE-2021-36159".to_string(),
                    "https://www.cve.org/CVERecord?id=CVE-2021-36159".to_string(),
                ],
            ),
            cvss: Some(cvvs),
            suppressed: false,
            vex_status: None
        }
    }

    #[test]
    fn test_vulnerability_has_fix() {
        let vuln = vulnerability();
        assert!(vuln.has_fix());

        let mut no_fix_vuln = vulnerability();
        no_fix_vuln.fixed_versions = Some(vec![]);
        assert!(!no_fix_vuln.has_fix());

        let mut none_fix_vuln = vulnerability();
        none_fix_vuln.fixed_versions = None;
        assert!(!none_fix_vuln.has_fix());
    }
}
