use std::collections::HashSet;

use k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

use crate::sbomscanner::storage::v1alpha1::{
    scan_result::ScanResult,
    vulnerability::{Severity, Vulnerability},
};

#[cfg(not(target_arch = "wasm32"))]
use crate::sbomscanner::storage::v1alpha1::image_metadata::ImageMetadata;

/// Report contains metadata about the scanned image and a list of vulnerability
/// results.
#[derive(
    Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize, schemars::JsonSchema,
)]
#[serde(rename_all = "camelCase")]
pub(crate) struct Report {
    /// Results per target (e.g., layer, package type)
    pub results: Vec<ScanResult>,

    /// Summary of vulnerabilities found
    #[cfg(not(target_arch = "wasm32"))]
    pub summary: Summary,
}

impl k8s_openapi::DeepMerge for Report {
    fn merge_from(&mut self, other: Self)
    where
        Self: Sized,
    {
        k8s_openapi::merge_strategies::list::set(&mut self.results, other.results);

        #[cfg(not(target_arch = "wasm32"))]
        self.summary.merge_from(other.summary);
    }
}

impl Report {
    /// returns a set of all unique vulnerability IDs (CVEs) found in the report
    pub fn vulnerabilties_ids(&self) -> HashSet<String> {
        let mut ids = HashSet::new();
        for result in &self.results {
            for vulnerability in &result.vulnerabilities {
                ids.insert(vulnerability.cve.clone());
            }
        }
        ids
    }

    pub fn critical_severity_vulnerabilitiest_with_fixes(
        &self,
        always_allowed: &HashSet<String>,
        ignore_vex_status: bool,
    ) -> Vec<&Vulnerability> {
        self.find_vulnerabilities(Severity::Critical, true, always_allowed, ignore_vex_status)
    }

    pub fn critical_severity_vulnerabilities_without_fixes(
        &self,
        always_allowed: &HashSet<String>,
        ignore_vex_status: bool,
    ) -> Vec<&Vulnerability> {
        self.find_vulnerabilities(Severity::Critical, false, always_allowed, ignore_vex_status)
    }

    pub fn high_severity_vulnerabilities_with_fixes(
        &self,
        always_allowed: &HashSet<String>,
        ignore_vex_status: bool,
    ) -> Vec<&Vulnerability> {
        self.find_vulnerabilities(Severity::High, true, always_allowed, ignore_vex_status)
    }

    pub fn high_severity_vulnerabilities_without_fixes(
        &self,
        always_allowed: &HashSet<String>,
        ignore_vex_status: bool,
    ) -> Vec<&Vulnerability> {
        self.find_vulnerabilities(Severity::High, false, always_allowed, ignore_vex_status)
    }

    pub fn medium_severity_vulnerabilities_with_fixes(
        &self,
        always_allowed: &HashSet<String>,
        ignore_vex_status: bool,
    ) -> Vec<&Vulnerability> {
        self.find_vulnerabilities(Severity::Medium, true, always_allowed, ignore_vex_status)
    }

    pub fn medium_severity_vulnerabilities_without_fixes(
        &self,
        always_allowed: &HashSet<String>,
        ignore_vex_status: bool,
    ) -> Vec<&Vulnerability> {
        self.find_vulnerabilities(Severity::Medium, false, always_allowed, ignore_vex_status)
    }

    pub fn low_severity_vulnerabilities_with_fixes(
        &self,
        always_allowed: &HashSet<String>,
        ignore_vex_status: bool,
    ) -> Vec<&Vulnerability> {
        self.find_vulnerabilities(Severity::Low, true, always_allowed, ignore_vex_status)
    }

    pub fn low_severity_vulnerabilities_without_fixes(
        &self,
        always_allowed: &HashSet<String>,
        ignore_vex_status: bool,
    ) -> Vec<&Vulnerability> {
        self.find_vulnerabilities(Severity::Low, false, always_allowed, ignore_vex_status)
    }

    fn find_vulnerabilities(
        &self,
        severity: Severity,
        has_fix: bool,
        always_allowed: &HashSet<String>,
        ignore_vex_status: bool,
    ) -> Vec<&Vulnerability> {
        let mut vuls = Vec::new();
        for result in &self.results {
            for vulnerability in &result.vulnerabilities {
                if always_allowed.contains(&vulnerability.cve) {
                    continue;
                }
                if vulnerability.severity == severity
                    && (has_fix == vulnerability.has_fix())
                    && (ignore_vex_status || !vulnerability.suppressed)
                {
                    vuls.push(vulnerability);
                }
            }
        }
        vuls
    }
}

/// Summary provides a high-level overview of the vulnerabilities found.
#[cfg(not(target_arch = "wasm32"))]
#[derive(
    Clone, Default, Debug, PartialEq, serde::Deserialize, serde::Serialize, schemars::JsonSchema,
)]
#[serde(rename_all = "camelCase")]
pub(crate) struct Summary {
    // Critical vulnerabilities count
    critical: i32,

    // High vulnerabilities count
    high: i32,

    // Medium vulnerabilities count
    medium: i32,

    // Low vulnerabilities count
    low: i32,

    // Unknown vulnerabilities count
    unknown: i32,

    // Suppressed vulnerabilities count
    suppressed: i32,
}

#[cfg(not(target_arch = "wasm32"))]
impl k8s_openapi::DeepMerge for Summary {
    fn merge_from(&mut self, other: Self)
    where
        Self: Sized,
    {
        self.critical.merge_from(other.critical);
        self.high.merge_from(other.high);
        self.medium.merge_from(other.medium);
        self.low.merge_from(other.low);
        self.unknown.merge_from(other.unknown);
        self.suppressed.merge_from(other.suppressed);
    }
}

#[derive(
    Clone, Default, Debug, PartialEq, serde::Deserialize, serde::Serialize, schemars::JsonSchema,
)]
#[serde(rename_all = "camelCase")]
pub(crate) struct VulnerabilityReport {
    pub metadata: ObjectMeta,

    /// ImageMetadata contains info about the scanned image
    #[cfg(not(target_arch = "wasm32"))]
    pub image_metadata: ImageMetadata,

    /// Report is the actual vulnerability scan report
    pub report: Report,
}

impl k8s_openapi::DeepMerge for VulnerabilityReport {
    fn merge_from(&mut self, other: Self)
    where
        Self: Sized,
    {
        #[cfg(not(target_arch = "wasm32"))]
        self.image_metadata.merge_from(other.image_metadata);

        self.report.merge_from(other.report);
    }
}

impl k8s_openapi::Resource for VulnerabilityReport {
    const API_VERSION: &'static str = "storage.sbomscanner.kubewarden.io/v1alpha1";
    const GROUP: &'static str = "storage.sbomscanner.kubewarden.io";
    const KIND: &'static str = "VulnerabilityReport";
    const VERSION: &'static str = "v1alpha1";
    const URL_PATH_SEGMENT: &'static str = "vulnerabilityreports";
    type Scope = k8s_openapi::NamespaceResourceScope;
}

impl k8s_openapi::ListableResource for VulnerabilityReport {
    const LIST_KIND: &'static str = "VulnerabilityReportList";
}

#[cfg(test)]
mod tests {
    use super::*;

    use crate::sbomscanner::storage::v1alpha1::{
        scan_result::Class,
        vulnerability::{Cvss, Severity},
    };

    #[test]
    fn parse_vulnerability_report() {
        let vulnerability_report_yaml =
            include_bytes!("../../../../test_data/vulnerabilityreport.yaml");

        let report: VulnerabilityReport =
            serde_yaml::from_slice(vulnerability_report_yaml).expect("cannot parse yaml");

        assert_eq!(
            report.image_metadata.digest,
            "sha256:1782cafde43390b032f960c0fad3def745fac18994ced169003cb56e9a93c028",
        );
        assert_eq!(report.image_metadata.platform, "linux/amd64");
        assert_eq!(report.image_metadata.registry, "sbomscanner-e2e");
        assert_eq!(report.image_metadata.registry_uri, "ghcr.io");
        assert_eq!(
            report.image_metadata.repository,
            "kubewarden-sandbox/sbomscanner/test-assets/golang"
        );
        assert_eq!(report.image_metadata.tag, "1.12-alpine");

        assert!(!report.report.results.is_empty());

        let scan_result = report.report.results.first().unwrap();
        assert_eq!(scan_result.class, Class::OsPackages);
        assert_eq!(scan_result.result_type, "alpine");

        // Check a vulnerability
        let mut cvvs_expected = std::collections::BTreeMap::new();
        cvvs_expected.insert(
            "nvd".to_string(),
            Cvss {
                v3_vector: "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H".to_string(),
                v3_score: "9.1".to_string(),
            },
        );
        cvvs_expected.insert(
            "redhat".to_string(),
            Cvss {
                v3_vector: "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H".to_string(),
                v3_score: "9.1".to_string(),
            },
        );

        let expected_vul = Vulnerability{
            cve: "CVE-2021-36159".to_string(),
            title: Some("libfetch: an out of boundary read while libfetch uses strtol to parse the relevant numbers into address bytes leads to information leak or crash".to_string()),
            package_name: Some("apk-tools".to_string()),
            package_path: None,
            purl: "pkg:apk/alpine/apk-tools@2.10.4-r3?arch=x86_64&distro=3.11.3".to_string(),
            installed_version: "2.10.4-r3".to_string(),
            fixed_versions: Some(vec!["2.10.7-r0".to_string()]),
            diff_id: "sha256:5216338b40a7b96416b8b9858974bbe4acc3096ee60acbc4dfb1ee02aecceb10".to_string(),
            description: Some("libfetch before 2021-07-26, as used in apk-tools, xbps, and other products, mishandles numeric strings for the FTP and HTTP protocols. The FTP passive mode implementation allows an out-of-bounds read because strtol is used to parse the relevant numbers into address bytes. It does not check if the line ends prematurely. If it does, the for-loop condition checks for the '\\0' terminator one byte too late.".to_string()),
            severity: Severity::Critical,
            references: Some(
                vec![
                    "https://access.redhat.com/security/cve/CVE-2021-36159".to_string(),
                    "https://github.com/freebsd/freebsd-src/commits/main/lib/libfetch".to_string(),
                    "https://gitlab.alpinelinux.org/alpine/apk-tools/-/issues/10749".to_string(),
                    "https://lists.apache.org/thread.html/r61db8e7dcb56dc000a5387a88f7a473bacec5ee01b9ff3f55308aacc%40%3Cdev.kafka.apache.org%3E".to_string(),
                    "https://lists.apache.org/thread.html/r61db8e7dcb56dc000a5387a88f7a473bacec5ee01b9ff3f55308aacc%40%3Cusers.kafka.apache.org%3E".to_string(),
                    "https://lists.apache.org/thread.html/rbf4ce74b0d1fa9810dec50ba3ace0caeea677af7c27a97111c06ccb7%40%3Cdev.kafka.apache.org%3E".to_string(),
                    "https://lists.apache.org/thread.html/rbf4ce74b0d1fa9810dec50ba3ace0caeea677af7c27a97111c06ccb7%40%3Cusers.kafka.apache.org%3E".to_string(),
                    "https://nvd.nist.gov/vuln/detail/CVE-2021-36159".to_string(),
                    "https://www.cve.org/CVERecord?id=CVE-2021-36159".to_string(),
                ],
            ),
            cvss: Some(cvvs_expected),
            suppressed: false,
            vex_status: None
        };

        let vuln = scan_result.vulnerabilities.first().unwrap();
        assert_eq!(vuln, &expected_vul);
    }

    #[test]
    fn test_find_vulnerabilities() {
        let critical_no_fix = Vulnerability {
            cve: "critical-no-fix".to_string(),
            title: None,
            package_name: None,
            package_path: None,
            purl: "critical-no-fix".to_string(),
            installed_version: "123".to_string(),
            fixed_versions: None,
            diff_id: "sha".to_string(),
            description: None,
            severity: Severity::Critical,
            references: None,
            cvss: None,
            suppressed: false,
            vex_status: None,
        };

        let critical_with_fix = Vulnerability {
            cve: "critical-with-fix".to_string(),
            title: None,
            package_name: None,
            package_path: None,
            purl: "critical-with-fix".to_string(),
            installed_version: "123".to_string(),
            fixed_versions: Some(vec!["1.2.3".to_string()]),
            diff_id: "sha".to_string(),
            description: None,
            severity: Severity::Critical,
            references: None,
            cvss: None,
            suppressed: false,
            vex_status: None,
        };

        let medium_no_fix = Vulnerability {
            cve: "medium-no-fix".to_string(),
            title: None,
            package_name: None,
            package_path: None,
            purl: "medium-no-fix".to_string(),
            installed_version: "123".to_string(),
            fixed_versions: None,
            diff_id: "sha".to_string(),
            description: None,
            severity: Severity::Medium,
            references: None,
            cvss: None,
            suppressed: false,
            vex_status: None,
        };

        let medium_with_fix = Vulnerability {
            cve: "medium-with-fix".to_string(),
            title: None,
            package_name: None,
            package_path: None,
            purl: "medium-with-fix".to_string(),
            installed_version: "123".to_string(),
            fixed_versions: Some(vec!["1.2.3".to_string()]),
            diff_id: "sha".to_string(),
            description: None,
            severity: Severity::Medium,
            references: None,
            cvss: None,
            suppressed: false,
            vex_status: None,
        };

        let low_with_fix_suppressed = Vulnerability {
            cve: "low-with-fix-suppressed".to_string(),
            title: None,
            package_name: None,
            package_path: None,
            purl: "low-with-fix-suppressed".to_string(),
            installed_version: "123".to_string(),
            fixed_versions: Some(vec!["1.2.3".to_string()]),
            diff_id: "sha".to_string(),
            description: None,
            severity: Severity::Low,
            references: None,
            cvss: None,
            suppressed: true,
            vex_status: None,
        };

        let report = Report {
            results: vec![ScanResult {
                target: "layer1".to_string(),
                class: Class::OsPackages,
                result_type: "alpine".to_string(),
                vulnerabilities: vec![
                    critical_no_fix.clone(),
                    critical_with_fix.clone(),
                    medium_no_fix,
                    medium_with_fix,
                    low_with_fix_suppressed.clone(),
                ],
            }],
            summary: Summary {
                critical: 2,
                high: 0,
                medium: 2,
                low: 0,
                unknown: 0,
                suppressed: 1,
            },
        };

        // test find critical with fixes
        assert_eq!(
            report.critical_severity_vulnerabilitiest_with_fixes(&HashSet::new(), false),
            vec![&critical_with_fix]
        );

        // test find critical without fixes
        assert_eq!(
            report.critical_severity_vulnerabilities_without_fixes(&HashSet::new(), false),
            vec![&critical_no_fix]
        );

        // test find critical with fixes allowing one cve
        assert!(
            report
                .critical_severity_vulnerabilitiest_with_fixes(
                    &vec![critical_with_fix.cve]
                        .into_iter()
                        .collect::<HashSet::<String>>(),
                    false
                )
                .is_empty()
        );

        // test find low with fixes, do not ignore vex status
        assert_eq!(
            report.low_severity_vulnerabilities_with_fixes(&HashSet::new(), false),
            Vec::<&Vulnerability>::new()
        );

        // test find low with fixes, ignore vex status
        assert_eq!(
            report.low_severity_vulnerabilities_with_fixes(&HashSet::new(), true),
            vec![&low_with_fix_suppressed]
        );
    }
}
