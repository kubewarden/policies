use crate::sbomscanner::storage::v1alpha1::vulnerability::Vulnerability;

/// Enumeration of supported package classes
#[cfg(not(target_arch = "wasm32"))]
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize, schemars::JsonSchema)]
pub(crate) enum Class {
    /// Operating system packages (e.g., deb, rpm)
    #[serde(rename = "os-pkgs")]
    OsPackages,

    /// Language-specific packages (e.g., npm, pip)
    #[serde(rename = "lang-pkgs")]
    LangPackages,

    /// Standalone binaries not part of a package manager
    #[serde(rename = "binary")]
    Binary,
}

/// ScanResult represents scan findings for a specific target and class of packages
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize, schemars::JsonSchema)]
#[serde(rename_all = "camelCase")]
#[serde(rename = "Result")]
pub(crate) struct ScanResult {
    /// Target is the specific target scanned
    #[cfg(not(target_arch = "wasm32"))]
    pub target: String,

    /// Class is the classification of the target
    #[cfg(not(target_arch = "wasm32"))]
    pub class: Class,

    // the language type
    #[serde(rename = "type")]
    #[cfg(not(target_arch = "wasm32"))]
    pub result_type: String,

    /// Vulnerabilities found in this target
    pub vulnerabilities: Vec<Vulnerability>,
}

impl k8s_openapi::DeepMerge for ScanResult {
    fn merge_from(&mut self, other: Self)
    where
        Self: Sized,
    {
        cfg_if::cfg_if! {
            if #[cfg(not(target_arch = "wasm32"))] {
                self.target.merge_from(other.target);
                self.class = other.class;
                self.result_type.merge_from(other.result_type);
            }
        }
        k8s_openapi::merge_strategies::list::set(&mut self.vulnerabilities, other.vulnerabilities);
    }
}
