use std::collections::{HashMap, HashSet};

mod sbomscanner;
use sbomscanner::storage::v1alpha1::{VulnerabilityReport, vulnerability::Vulnerability};

mod settings;
use settings::{ImageLookupStrategy, Platform, Settings, SeverityCount, sbomscanner_platform};

mod errors;
use errors::{CVEViolationStats, ImageValidationError, Violation};

use criteria_policy_base::validate::validate_values;

use guest::prelude::*;
use kubewarden_policy_sdk::{
    host_capabilities::{kubernetes::ListResourcesByNamespaceRequest, oci::OciManifestResponse},
    wapc_guest as guest,
};
use oci_spec::image::Platform as OciPlatform;

use k8s_openapi::{
    Metadata, Resource,
    api::{
        apps::v1::{DaemonSet, Deployment, ReplicaSet, StatefulSet},
        batch::v1::{CronJob, Job},
        core::v1::{Pod, PodSpec, ReplicationController},
    },
    apimachinery::pkg::apis::meta::v1::ObjectMeta,
};
use kubewarden_policy_sdk::{
    accept_request, logging, protocol_version_guest, reject_request, request::ValidationRequest,
    validate_settings,
};
use lazy_static::lazy_static;
use serde::de::DeserializeOwned;
use slog::{Logger, debug, info, o, warn};

#[cfg(test)]
use crate::tests::{
    mock_kubernetes_sdk::list_resources_by_namespace,
    mock_oci_sdk::{get_manifest, get_manifest_digest},
};

#[cfg(not(test))]
use kubewarden_policy_sdk::host_capabilities::{
    kubernetes::list_resources_by_namespace,
    oci::{get_manifest, get_manifest_digest},
};

type ImageValidationErrors = HashMap<String, ImageValidationError>;

lazy_static! {
    static ref LOG_DRAIN: Logger =
        Logger::root(logging::KubewardenDrain::new(), o!("policy" => "image-cve"));
}

#[unsafe(no_mangle)]
pub extern "C" fn wapc_init() {
    register_function("validate", validate);
    register_function("validate_settings", validate_settings::<Settings>);
    register_function("protocol_version", protocol_version_guest);
}

fn validate(payload: &[u8]) -> CallResult {
    let validation_request: ValidationRequest<Settings> = ValidationRequest::new(payload)?;

    match validation_request.request.kind.kind.as_str() {
        "Deployment" => validate_resource::<Deployment>(validation_request, |deployment| {
            deployment.spec.as_ref()?.template.spec.clone()
        }),
        "ReplicaSet" => validate_resource::<ReplicaSet>(validation_request, |replicaset| {
            replicaset.spec.as_ref()?.template.as_ref()?.spec.clone()
        }),
        "StatefulSet" => validate_resource::<StatefulSet>(validation_request, |statefulset| {
            statefulset.spec.as_ref()?.template.spec.clone()
        }),
        "DaemonSet" => validate_resource::<DaemonSet>(validation_request, |daemonset| {
            daemonset.spec.as_ref()?.template.spec.clone()
        }),
        "ReplicationController" => {
            validate_resource::<ReplicationController>(validation_request, |rc| {
                rc.spec.as_ref()?.template.as_ref()?.spec.clone()
            })
        }
        "Job" => validate_resource::<Job>(validation_request, |job| {
            job.spec.as_ref()?.template.spec.clone()
        }),
        "CronJob" => validate_resource::<CronJob>(validation_request, |cronjob| {
            cronjob
                .spec
                .as_ref()?
                .job_template
                .spec
                .as_ref()?
                .template
                .spec
                .clone()
        }),
        "Pod" => validate_resource::<Pod>(validation_request, |pod| pod.spec.clone()),
        _ => {
            warn!(
                LOG_DRAIN,
                "cannot unmarshal resource: this policy does not know how to evaluate this resource; accept it"
            );
            accept_request()
        }
    }
}

// validate any resource that contains a Pod. e.g. Deployment, StatefulSet, ...
// it does not modify the container with the manifest digest.
fn validate_resource<T>(
    validation_request: ValidationRequest<Settings>,
    extract_spec: fn(&T) -> Option<PodSpec>,
) -> CallResult
where
    T: Resource + Metadata<Ty = ObjectMeta> + DeserializeOwned,
{
    let resource = match serde_json::from_value::<T>(validation_request.request.object.clone()) {
        Ok(resource) => resource,
        Err(_) => {
            warn!(
                LOG_DRAIN,
                "cannot unmarshal resource: this policy does not know how to evaluate this resource; accept it"
            );
            return accept_request();
        }
    };

    let spec = match extract_spec(&resource) {
        Some(spec) => spec,
        None => {
            return accept_request();
        }
    };

    let mut image_validation_errors = ImageValidationErrors::new();

    verify_all_images_in_podspec(
        &spec,
        &validation_request.settings,
        &mut image_validation_errors,
    );

    if image_validation_errors.is_empty() {
        return accept_request();
    }

    let rejection_details = image_validation_errors
        .iter()
        .map(|(image, error)| format!("{image}: {error}"))
        .collect::<Vec<String>>()
        .join(", ");

    reject_request(
        Some(format!(
            "Resource {} is not accepted: {}",
            resource.metadata().name.as_ref().unwrap(),
            rejection_details,
        )),
        None,
        None,
        None,
    )
}
/// verify all images defined in the PodSpec. The violations are stored in the `image_validation_errors` map.
fn verify_all_images_in_podspec(
    spec: &PodSpec,
    settings: &Settings,
    image_validation_errors: &mut ImageValidationErrors,
) {
    let mut images: Vec<String> = spec
        .containers
        .iter()
        .map(|c| c.image.clone().unwrap())
        .collect();

    if let Some(init_containers) = &spec.init_containers {
        let init_images: Vec<String> = init_containers
            .iter()
            .map(|c| c.image.clone().unwrap())
            .collect();
        images.extend(init_images);
    }

    if let Some(ephemeral_containers) = &spec.ephemeral_containers {
        let ephemeral_images: Vec<String> = ephemeral_containers
            .iter()
            .map(|c| c.image.clone().unwrap())
            .collect();

        images.extend(ephemeral_images);
    }

    for image in images {
        verify_container_image(&image, settings, image_validation_errors);
    }
}

/// Verify the given image. The violations are stored in the `image_validation_errors` map.
fn verify_container_image(
    image: &str,
    settings: &Settings,
    image_validation_errors: &mut ImageValidationErrors,
) {
    if image_validation_errors.contains_key(image) {
        return;
    }

    let vulnerability_report = match settings.image_lookup_strategy {
        ImageLookupStrategy::Digest => {
            let digest = match get_image_digest(image, settings.platform.as_ref()) {
                Ok(digest) => digest,
                Err(e) => {
                    if settings.ignore_missing_vulnerability_report {
                        info!(LOG_DRAIN,
                                "ignoring error while attempting to fetch the image manifest because ignoreMissingVulnerabilityReport is enabled";
                                "image" => image,
                                "error" => ?e,
                        );

                        return;
                    }
                    image_validation_errors.insert(image.to_string(), e);
                    return;
                }
            };

            get_vulnerability_report_by_digest(&digest, settings)
        }
        ImageLookupStrategy::Tag => match get_vulnerability_report_by_tag(image, settings) {
            Ok(vr) => vr,
            Err(e) => {
                image_validation_errors.insert(image.to_string(), e);
                return;
            }
        },
    };

    if let Err(e) = process_vulnerability_report(vulnerability_report, image, settings) {
        image_validation_errors.insert(image.to_string(), e);
    }
}

/// Obtains the manifest of the image. This can be done either by extracting the digest from the image reference or by fetching the manifest from the registry.
fn get_image_digest(
    image: &str,
    platform: Option<&Platform>,
) -> Result<String, ImageValidationError> {
    // The image reference might already contain its digest,
    // in that case we can return it directly, saving a network call
    let image_ref: oci_spec::distribution::Reference =
        image
            .parse()
            .map_err(|e: oci_spec::distribution::ParseError| {
                ImageValidationError::MalformedImageName(e.to_string())
            })?;
    if let Some(digest) = image_ref.digest() {
        return Ok(digest.to_string());
    }

    let manifest =
        get_manifest(image).map_err(|e| ImageValidationError::ManifestFetchError(e.to_string()))?;

    let digest = match manifest {
        OciManifestResponse::Image(_) => {
            // This is a single arch image, we have to get the digest by doing another remote
            // call
            let digest_response = get_manifest_digest(image)
                .map_err(|e| ImageValidationError::ManifestFetchError(e.to_string()))?;
            digest_response.digest
        }
        OciManifestResponse::ImageIndex(image_index) => {
            // This is a multi arch image, we can find the digest of the desired platform
            // in the index itself
            let platform: OciPlatform =
                platform.map_or_else(host_platorm, |p| Ok(Into::<OciPlatform>::into(p)))?;

            let platform_descriptor = image_index
                .manifests()
                .iter()
                .find(|descriptor| descriptor.platform().as_ref() == Some(&platform))
                .ok_or_else(|| {
                    ImageValidationError::ManifestFetchError(format!(
                        "cannot find a manifest for the specified platform: {platform:?}"
                    ))
                })?;
            platform_descriptor.digest().to_string()
        }
    };

    Ok(digest)
}

// TODO: detect host architecture by introducing a new host capability
fn host_platorm() -> Result<OciPlatform, ImageValidationError> {
    let mut platform = OciPlatform::default();

    platform.set_architecture("amd64".into());
    platform.set_os("linux".into());

    Ok(platform)
}

/// Given the digest of an image, it fetches the vulnerability report from Kubernetes.
fn get_vulnerability_report_by_digest(
    digest: &str,
    settings: &Settings,
) -> Option<VulnerabilityReport> {
    let namespace = settings.vulnerability_report_namespace.as_str();

    let vulnerability_reports =
        match list_resources_by_namespace(&ListResourcesByNamespaceRequest {
            api_version: "storage.sbomscanner.kubewarden.io/v1alpha1".to_string(),
            kind: "VulnerabilityReport".to_string(),
            namespace: namespace.to_string(),
            label_selector: None,
            field_selector: Some(format!("imageMetadata.digest={digest}")),
        }) {
            Ok(report) => report,
            Err(e) => {
                warn!(LOG_DRAIN, "error fetching vulnerability report";
                               "error" => ?e,
                               "digest" => digest,
                               "namespace" => namespace,
                );
                return None;
            }
        };

    if vulnerability_reports.items.is_empty() {
        return None;
    }

    vulnerability_reports.items.into_iter().next()
}

/// Given the tag of an image, it fetches the vulnerability report from Kubernetes.
fn get_vulnerability_report_by_tag(
    image: &str,
    settings: &Settings,
) -> Result<Option<VulnerabilityReport>, ImageValidationError> {
    // Parse the image reference to extract repository and tag
    let image_ref: oci_spec::distribution::Reference =
        image
            .parse()
            .map_err(|e: oci_spec::distribution::ParseError| {
                ImageValidationError::MalformedImageName(e.to_string())
            })?;

    // The image reference might already contain its digest,
    // in that case we stick to using the digest
    if image_ref.digest().is_some() {
        return Ok(get_vulnerability_report_by_digest(image, settings));
    }

    let repository = image_ref.repository();
    let tag = image_ref.tag().unwrap_or("latest");

    let namespace = settings.vulnerability_report_namespace.as_str();

    let platform_sbomscanner = if let Some(platform) = &settings.platform {
        sbomscanner_platform(&platform.into())
    } else {
        sbomscanner_platform(&host_platorm()?)
    };

    let vulnerability_reports =
        match list_resources_by_namespace(&ListResourcesByNamespaceRequest {
            api_version: "storage.sbomscanner.kubewarden.io/v1alpha1".to_string(),
            kind: "VulnerabilityReport".to_string(),
            namespace: namespace.to_string(),
            label_selector: None,
            field_selector: Some(format!(
                "imageMetadata.repository={},imageMetadata.tag={},platform={}",
                repository, tag, platform_sbomscanner
            )),
        }) {
            Ok(report) => report,
            Err(e) => {
                warn!(LOG_DRAIN, "error fetching vulnerability report";
                               "error" => ?e,
                               "repository" => repository,
                               "tag" => tag,
                               "namespace" => namespace,
                );
                return Ok(None);
            }
        };

    if vulnerability_reports.items.is_empty() {
        return Ok(None);
    }

    Ok(vulnerability_reports.items.into_iter().next())
}

/// Processes a vulnerability report, handling missing reports according to settings.
fn process_vulnerability_report(
    vulnerability_report: Option<VulnerabilityReport>,
    image: &str,
    settings: &Settings,
) -> Result<(), ImageValidationError> {
    match vulnerability_report {
        None => {
            if settings.ignore_missing_vulnerability_report {
                info!(LOG_DRAIN,
                    "ignoring missing vulnerability report because ignoreMissingVulnerabilityReport is enabled";
                    "image" => image,
                );
                Ok(())
            } else {
                Err(ImageValidationError::VulnerabilityReportNotFound())
            }
        }
        Some(report) => verify_vulnerability_report(&report.report, settings),
    }
}

fn count_vulnerabilities_with_cvss_above_threshold(
    report: &sbomscanner::storage::v1alpha1::Report,
    threshold: f32,
    always_allowed: &HashSet<String>,
    ignore_vex_status: bool,
) -> usize {
    report
        .results
        .iter()
        .flat_map(|result| &result.vulnerabilities)
        .filter(|vuln| {
            !((always_allowed.contains(&vuln.cve)) || ignore_vex_status || vuln.suppressed)
        })
        .filter_map(|vuln| {
            vuln.cvss
                .as_ref()
                .and_then(|cvss| {
                    cvss.get("nvd")
                        .or_else(|| cvss.get("redhat"))
                        .or_else(|| cvss.get("ghsa"))
                        .or_else(|| cvss.get("bitnami"))
                        .or_else(|| cvss.values().next())
                })
                .and_then(|entry| entry.v3_score.parse::<f32>().ok())
        })
        .filter(|&score| score >= threshold)
        .count()
}

fn verify_vulnerability_report(
    report: &sbomscanner::storage::v1alpha1::Report,
    settings: &Settings,
) -> Result<(), ImageValidationError> {
    let always_denied_cves: Vec<String> = report
        .vulnerabilties_ids()
        .intersection(&settings.deny_always)
        .cloned()
        .collect();
    if !always_denied_cves.is_empty() {
        return Err(ImageValidationError::AffectedByDeniedCVE(
            always_denied_cves,
        ));
    }

    if let Some(cve_name_criteria) = &settings.cve_name {
        // get all of the cve names from the report
        let cves: Vec<String> = report
            .results
            .iter()
            .flat_map(|result| result.vulnerabilities.iter().map(|v| v.cve.to_string()))
            .collect();

        validate_values(cve_name_criteria, &cves)
            .map_err(|e| ImageValidationError::CVENameMatchFailed(e.to_string()))?;
    }

    if let Some(cvss_score) = &settings.cvss_score {
        let cvss_violation_count = count_vulnerabilities_with_cvss_above_threshold(
            report,
            cvss_score.threshold,
            &settings.allow_always,
            settings.ignore_vex_status,
        );

        if cvss_violation_count > usize::try_from(cvss_score.max_count).unwrap_or_default() {
            return Err(ImageValidationError::CvssScoreThresholdExceeded {
                threshold: cvss_score.threshold,
                max_count: cvss_score.max_count,
                count: cvss_violation_count,
            });
        }
    }

    if !settings
        .max_severity
        .as_ref()
        .map_or_else(|| false, |ms| ms.is_configured())
    {
        return Ok(());
    }

    let max_severity = settings.max_severity.as_ref().unwrap();

    let violation_stats = CVEViolationStats {
        critical: find_violation(
            max_severity.critical.as_ref(),
            &report.critical_severity_vulnerabilitiest_with_fixes(
                &settings.allow_always,
                settings.ignore_vex_status,
            ),
            &report.critical_severity_vulnerabilities_without_fixes(
                &settings.allow_always,
                settings.ignore_vex_status,
            ),
        ),
        high: find_violation(
            max_severity.high.as_ref(),
            &report.high_severity_vulnerabilities_with_fixes(
                &settings.allow_always,
                settings.ignore_vex_status,
            ),
            &report.high_severity_vulnerabilities_without_fixes(
                &settings.allow_always,
                settings.ignore_vex_status,
            ),
        ),
        medium: find_violation(
            max_severity.medium.as_ref(),
            &report.medium_severity_vulnerabilities_with_fixes(
                &settings.allow_always,
                settings.ignore_vex_status,
            ),
            &report.medium_severity_vulnerabilities_without_fixes(
                &settings.allow_always,
                settings.ignore_vex_status,
            ),
        ),
        low: find_violation(
            max_severity.low.as_ref(),
            &report.low_severity_vulnerabilities_with_fixes(
                &settings.allow_always,
                settings.ignore_vex_status,
            ),
            &report.low_severity_vulnerabilities_without_fixes(
                &settings.allow_always,
                settings.ignore_vex_status,
            ),
        ),
    };

    if violation_stats.has_violations() {
        return Err(ImageValidationError::MaxSeverityExceeded(Box::new(
            violation_stats,
        )));
    }

    Ok(())
}

fn find_violation(
    severity_count: Option<&SeverityCount>,
    vulnerabilities_with_fixes: &[&Vulnerability],
    vulnerabilities_without_fixes: &[&Vulnerability],
) -> Option<Violation> {
    debug!(LOG_DRAIN, "checking severity";
           "severity_count" => ?severity_count,
           "vulnerabilities_with_fixes" => vulnerabilities_with_fixes.len(),
           "vulnerabilities_without_fixes" => vulnerabilities_without_fixes.len(),
    );
    match severity_count {
        Some(settings::SeverityCount::Total(max)) => {
            let total = vulnerabilities_with_fixes.len() as u32
                + vulnerabilities_without_fixes.len() as u32;
            if total > *max {
                let ids_with_fix: HashSet<String> = vulnerabilities_with_fixes
                    .iter()
                    .map(|v| v.cve.to_owned())
                    .collect();
                let ids_without_fix: HashSet<String> = vulnerabilities_without_fixes
                    .iter()
                    .map(|v| v.cve.to_owned())
                    .collect();

                Some(errors::Violation {
                    allowed: settings::SeverityCount::Total(*max),
                    actual: total,
                    vulnerabilities: ids_without_fix.union(&ids_with_fix).cloned().collect(),
                })
            } else {
                None
            }
        }
        Some(settings::SeverityCount::TotalWithoutFixes(max)) => {
            if vulnerabilities_without_fixes.len() as u32 > *max {
                let ids: Vec<String> = vulnerabilities_without_fixes
                    .iter()
                    .map(|v| v.cve.to_owned())
                    .collect();

                Some(errors::Violation {
                    allowed: settings::SeverityCount::TotalWithoutFixes(*max),
                    actual: vulnerabilities_without_fixes.len() as u32,
                    vulnerabilities: ids,
                })
            } else {
                None
            }
        }
        None => None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use anyhow::anyhow;
    use criteria_policy_base::settings::BaseSettings;
    use kubewarden_policy_sdk::{
        host_capabilities::oci::ManifestDigestResponse,
        request::{GroupVersionKind, KubernetesAdmissionRequest},
        response::ValidationResponse,
    };
    use mockall::automock;
    use rstest::rstest;
    use serde_json::json;
    use serial_test::serial;

    #[automock()]
    pub mod kubernetes_sdk {
        use kubewarden_policy_sdk::host_capabilities::kubernetes::ListResourcesByNamespaceRequest;

        #[allow(dead_code)]
        pub fn list_resources_by_namespace<T>(
            _req: &ListResourcesByNamespaceRequest,
        ) -> anyhow::Result<k8s_openapi::List<T>>
        where
            T: k8s_openapi::ListableResource + serde::de::DeserializeOwned + Clone + 'static,
        {
            Err(anyhow::anyhow!("not mocked"))
        }
    }

    #[automock()]
    pub mod oci_sdk {
        use kubewarden_policy_sdk::host_capabilities::oci::{
            ManifestDigestResponse, OciManifestResponse,
        };

        #[allow(dead_code)]
        pub fn get_manifest_digest(_image: &str) -> anyhow::Result<ManifestDigestResponse> {
            Err(anyhow::anyhow!("not mocked"))
        }

        #[allow(dead_code)]
        pub fn get_manifest(_image: &str) -> anyhow::Result<OciManifestResponse> {
            Err(anyhow::anyhow!("not mocked"))
        }
    }

    fn pod(image: &str) -> serde_json::Value {
        json!(
        {
          "apiVersion": "v1",
          "kind": "Pod",
          "metadata": {
            "name": "nginx"
          },
          "spec": {
            "containers": [
              {
                "image": image,
                "name": "test-verify-image-signatures"
              }
            ]
          }
        })
    }

    fn image_manifest() -> oci_spec::image::ImageManifest {
        // This is the easiest way to build an ImageManifest,
        // we're using the manifest of `ghcr.io/kubewarden/policy-server:v1.29.0`
        // for the `linux/amd64` platform

        let raw_manifest = json!(
            {
            "schemaVersion": 2,
            "mediaType": "application/vnd.oci.image.manifest.v1+json",
            "config": {
                "mediaType": "application/vnd.oci.image.config.v1+json",
                "digest": "sha256:3857df21b4e4f90fc904753677a08fb13a47f24000a129be60588710353738b6",
                "size": 1968
            },
            "layers": [
                {
                "mediaType": "application/vnd.oci.image.layer.v1.tar+gzip",
                "digest": "sha256:f8a3a5eb771b22d26a000098e434b25fe6fe008dd9e99e7452b6e1229c07ed59",
                "size": 21699173
                },
                {
                "mediaType": "application/vnd.oci.image.layer.v1.tar+gzip",
                "digest": "sha256:39f1378f315e78eaa6ab08eb6a95f70fe00cf4c7777551b9a5ac07bd59dacc4f",
                "size": 433
                },
                {
                "mediaType": "application/vnd.oci.image.layer.v1.tar+gzip",
                "digest": "sha256:d55e8c342fad6c5109c643566c08836219097c69ae4236d8172ce0e767502a88",
                "size": 427
                },
                {
                "mediaType": "application/vnd.oci.image.layer.v1.tar+gzip",
                "digest": "sha256:ed37efb4b497676dab1308f948bd85e85f2966268e99a79e72f67532abbffad5",
                "size": 43266
                }
            ]
            }
        );
        serde_json::from_value(raw_manifest).unwrap()
    }

    fn amd64_linux_platform() -> Platform {
        Platform {
            arch: oci_spec::image::Arch::Amd64,
            os: oci_spec::image::Os::Linux,
            os_version: None,
            os_features: None,
            variant: None,
        }
    }

    fn ppc64_linux_platform() -> Platform {
        Platform {
            arch: oci_spec::image::Arch::PowerPC,
            os: oci_spec::image::Os::Linux,
            os_version: None,
            os_features: None,
            variant: None,
        }
    }

    fn arm_linux_platform_missing_variant() -> Platform {
        Platform {
            arch: oci_spec::image::Arch::ARM,
            os: oci_spec::image::Os::Linux,
            os_version: None,
            os_features: None,
            variant: None,
        }
    }

    fn arm_linux_platform_with_variant() -> Platform {
        Platform {
            arch: oci_spec::image::Arch::ARM,
            os: oci_spec::image::Os::Linux,
            os_version: None,
            os_features: None,
            variant: Some("v6".to_string()),
        }
    }

    fn image_index() -> oci_spec::image::ImageIndex {
        // This is the easiest way to build an ImageIndex,
        // we're using the manifest of `ghcr.io/kubewarden-sandbox/sbomscanner/test-assets/golang:1.12-alpine`
        // image

        let raw_manifest = json!(
        {
            "manifests": [
                {
                    "digest": "sha256:1782cafde43390b032f960c0fad3def745fac18994ced169003cb56e9a93c028",
                    "mediaType": "application/vnd.docker.distribution.manifest.v2+json",
                    "platform": {
                        "architecture": "amd64",
                        "os": "linux"
                    },
                    "size": 1365
                },
                {
                    "digest": "sha256:ea95bb81dab31807beac6c62824c048b1ee96b408f6097ea9dd0204e380f00b2",
                    "mediaType": "application/vnd.docker.distribution.manifest.v2+json",
                    "platform": {
                        "architecture": "arm",
                        "os": "linux",
                        "variant": "v6"
                    },
                    "size": 1365
                },
                {
                    "digest": "sha256:ab389e320938f3bd42f45437d381fab28742dadcb892816236801e24a0bef804",
                    "mediaType": "application/vnd.docker.distribution.manifest.v2+json",
                    "platform": {
                        "architecture": "arm",
                        "os": "linux",
                        "variant": "v7"
                    },
                    "size": 1365
                },
                {
                    "digest": "sha256:1c96d48d06d96929d41e76e8145eb182ce22983f5e3539a655ec2918604835d0",
                    "mediaType": "application/vnd.docker.distribution.manifest.v2+json",
                    "platform": {
                        "architecture": "arm64",
                        "os": "linux",
                        "variant": "v8"
                    },
                    "size": 1365
                },
                {
                    "digest": "sha256:d8801b3783dd4e4aee273c1a312cc265c832c7f264056d68e7ea73b8e1dd94b0",
                    "mediaType": "application/vnd.docker.distribution.manifest.v2+json",
                    "platform": {
                        "architecture": "386",
                        "os": "linux"
                    },
                    "size": 1365
                },
                {
                    "digest": "sha256:216cb428a7a53a75ef7806ed1120c409253e3e65bddc6ae0c21f5cd2faf92324",
                    "mediaType": "application/vnd.docker.distribution.manifest.v2+json",
                    "platform": {
                        "architecture": "ppc64le",
                        "os": "linux"
                    },
                    "size": 1365
                },
                {
                    "digest": "sha256:f2475c61ab276da0882a9637b83b2a5710b289d6d80f3daedb71d4a8eaeb1686",
                    "mediaType": "application/vnd.docker.distribution.manifest.v2+json",
                    "platform": {
                        "architecture": "s390x",
                        "os": "linux"
                    },
                    "size": 1365
                }
            ],
            "mediaType": "application/vnd.docker.distribution.manifest.list.v2+json",
            "schemaVersion": 2
        }

        );
        serde_json::from_value(raw_manifest).unwrap()
    }

    // vulnerabilityreport.yaml Statistics:
    // - 4 critical vulnerability
    // - 29 high vulnerability
    // - 10 medium vulnerability
    // - 2 low vulnerability
    // - 0 unknown vulnerability
    // - 4 vulnerability with CVSS score 9.0
    // - 0 vulnerability with CVSS score 9.9
    #[rstest]
    #[case::always_denied_vulnerability_not_found_image_lookup_by_digest(
        Some("vulnerabilityreport.yaml".to_owned()),
        Settings {
            max_severity: None,
            allow_always: HashSet::new(),
            deny_always: vec!["CVE-2021-1234".to_string()].into_iter().collect(),
            ignore_missing_vulnerability_report: false,
            vulnerability_report_namespace: "sbomscanner".to_string(),
            ignore_vex_status: false,
            platform: Some(amd64_linux_platform()),
            cvss_score: None,
            cve_name: None,
            image_lookup_strategy: ImageLookupStrategy::Digest,
        },
        true
    )]
    #[case::always_denied_vulnerability_not_found_image_lookup_by_tag(
        Some("vulnerabilityreport.yaml".to_owned()),
        Settings {
            max_severity: None,
            allow_always: HashSet::new(),
            deny_always: vec!["CVE-2021-1234".to_string()].into_iter().collect(),
            ignore_missing_vulnerability_report: false,
            vulnerability_report_namespace: "sbomscanner".to_string(),
            ignore_vex_status: false,
            platform: Some(amd64_linux_platform()),
            cvss_score: None,
            cve_name: None,
            image_lookup_strategy: ImageLookupStrategy::Tag,
        },
        true
    )]
    #[case::always_denied_vulnerability_found_image_lookup_by_digest(
        Some("vulnerabilityreport.yaml".to_owned()),
        Settings {
            max_severity: None,
            allow_always: HashSet::new(),
            deny_always: vec!["CVE-2021-36159".to_string()].into_iter().collect(),
            ignore_missing_vulnerability_report: false,
            vulnerability_report_namespace: "sbomscanner".to_string(),
            ignore_vex_status: false,
            platform: Some(amd64_linux_platform()),
            cvss_score: None,
            cve_name: None,
            image_lookup_strategy: ImageLookupStrategy::Digest,
        },
        false
    )]
    #[case::always_denied_vulnerability_found_lookup_by_tag(
        Some("vulnerabilityreport.yaml".to_owned()),
        Settings {
            max_severity: None,
            allow_always: HashSet::new(),
            deny_always: vec!["CVE-2021-36159".to_string()].into_iter().collect(),
            ignore_missing_vulnerability_report: false,
            vulnerability_report_namespace: "sbomscanner".to_string(),
            ignore_vex_status: false,
            platform: Some(amd64_linux_platform()),
            cvss_score: None,
            cve_name: None,
            image_lookup_strategy: ImageLookupStrategy::Tag,
        },
        false
    )]
    #[case::no_critical_vulnerability_found(
        Some("vulnerabilityreport_no_critical.yaml".to_owned()),
        Settings {
            max_severity: Some(settings::MaxSeverity {
                critical: Some(SeverityCount::Total(0)),
                high: None,
                medium: None,
                low: None,
                unknown: None,
            }),
            allow_always: HashSet::new(),
            deny_always: HashSet::new(),
            ignore_missing_vulnerability_report: false,
            vulnerability_report_namespace: "sbomscanner".to_string(),
            ignore_vex_status: false,
            platform: Some(amd64_linux_platform()),
            cvss_score: None,
            cve_name: None,
            image_lookup_strategy: ImageLookupStrategy::Digest,
        },
        true
    )]
    #[case::too_many_low_vulnerabilities(
        Some("vulnerabilityreport.yaml".to_owned()),
        Settings {
            max_severity: Some(settings::MaxSeverity {
                critical: None,
                high: None,
                medium: None,
                low: Some(SeverityCount::Total(1)),
                unknown: None,
            }),
            allow_always: HashSet::new(),
            deny_always: HashSet::new(),
            ignore_missing_vulnerability_report: false,
            vulnerability_report_namespace: "sbomscanner".to_string(),
            ignore_vex_status: false,
            platform: Some(amd64_linux_platform()),
            cvss_score: None,
            cve_name: None,
            image_lookup_strategy: ImageLookupStrategy::Digest,
        },
        false
    )]
    #[case::too_many_medium_vulnerabilities(
        Some("vulnerabilityreport.yaml".to_owned()),
        Settings {
            max_severity: Some(settings::MaxSeverity {
                critical: None,
                high: None,
                medium: Some(SeverityCount::Total(4)),
                low: None,
                unknown: None,
            }),
            allow_always: HashSet::new(),
            deny_always: HashSet::new(),
            ignore_missing_vulnerability_report: false,
            vulnerability_report_namespace: "sbomscanner".to_string(),
            ignore_vex_status: false,
            platform: Some(amd64_linux_platform()),
            cvss_score: None,
            cve_name: None,
            image_lookup_strategy: ImageLookupStrategy::Digest,
        },
        false
    )]
    #[case::always_allowed_cve_found(
        Some("vulnerabilityreport.yaml".to_owned()),
        Settings {
            max_severity: Some(settings::MaxSeverity {
                critical: None,
                high: None,
                medium: None,
                low: Some(SeverityCount::Total(0)),
                unknown: None,
            }),
            // this is the only LOW vulnerability
            allow_always: vec![
                "CVE-2021-23839".to_string()
            ].into_iter().collect(),
            deny_always: HashSet::new(),
            ignore_missing_vulnerability_report: false,
            vulnerability_report_namespace: "sbomscanner".to_string(),
            ignore_vex_status: false,
            platform: Some(amd64_linux_platform()),
            cvss_score: None,
            cve_name: None,
            image_lookup_strategy: ImageLookupStrategy::Digest,
        },
        true
    )]
    #[case::vulnerability_report_not_found(
        None,
        Settings {
            max_severity: Some(settings::MaxSeverity {
                critical: None,
                high: None,
                medium: Some(SeverityCount::Total(0)),
                low: None,
                unknown: None,
            }),
            allow_always:  HashSet::new(),
            deny_always: HashSet::new(),
            ignore_missing_vulnerability_report: false,
            vulnerability_report_namespace: "sbomscanner".to_string(),
            ignore_vex_status: false,
            platform: Some(amd64_linux_platform()),
            cvss_score: None,
            cve_name: None,
            image_lookup_strategy: ImageLookupStrategy::Digest,
        },
        false
    )]
    #[case::vulnerability_report_not_found_ignore_missing(
        None,
        Settings {
            max_severity: Some(settings::MaxSeverity {
                critical: None,
                high: None,
                medium: Some(SeverityCount::Total(0)),
                low: None,
                unknown: None,
            }),
            allow_always:  HashSet::new(),
            deny_always: HashSet::new(),
            ignore_missing_vulnerability_report: true,
            vulnerability_report_namespace: "sbomscanner".to_string(),
            ignore_vex_status: false,
            platform: Some(amd64_linux_platform()),
            cvss_score: None,
            cve_name: None,
            image_lookup_strategy: ImageLookupStrategy::Digest,
        },
        true
    )]
    #[case::cvss_score_threshold_exceeded(
        Some("vulnerabilityreport.yaml".to_owned()),
        Settings {
            max_severity: None,
            allow_always:  HashSet::new(),
            deny_always: HashSet::new(),
            ignore_missing_vulnerability_report: false,
            vulnerability_report_namespace: "sbomscanner".to_string(),
            ignore_vex_status: false,
            platform: Some(amd64_linux_platform()),
            cvss_score: Some(settings::CvssScore { threshold: 7.0, max_count: 1 }),
            cve_name: None,
            image_lookup_strategy: ImageLookupStrategy::Digest,
        },
        false
    )]
    #[case::cvss_score_threshold_not_exceeded(
        Some("vulnerabilityreport.yaml".to_owned()),
        Settings {
            max_severity: None,
            allow_always:  HashSet::new(),
            deny_always: HashSet::new(),
            ignore_missing_vulnerability_report: false,
            vulnerability_report_namespace: "sbomscanner".to_string(),
            ignore_vex_status: false,
            platform: Some(amd64_linux_platform()),
            cvss_score: Some(settings::CvssScore { threshold: 9.9, max_count: 1 }),
            cve_name: None,
            image_lookup_strategy: ImageLookupStrategy::Digest,
        },
        true
    )]
    #[case::max_severity_not_exceeded_cvss_score_threshold_exceeded(
        Some("vulnerabilityreport.yaml".to_owned()),
        Settings {
            max_severity: Some(settings::MaxSeverity {
                critical: None,
                high: Some(SeverityCount::Total(10)),
                medium: Some(SeverityCount::Total(0)),
                low: None,
                unknown: None,
            }),
            allow_always:  HashSet::new(),
            deny_always: HashSet::new(),
            ignore_missing_vulnerability_report: false,
            vulnerability_report_namespace: "sbomscanner".to_string(),
            ignore_vex_status: false,
            platform: Some(amd64_linux_platform()),
            cvss_score: Some(settings::CvssScore { threshold: 9.0, max_count: 1 }),
            cve_name: None,
            image_lookup_strategy: ImageLookupStrategy::Digest,
        },
        false
    )]
    #[case::max_severity_exceeded_cvss_score_threshold_not_exceeded(
        Some("vulnerabilityreport.yaml".to_owned()),
        Settings {
            max_severity: Some(settings::MaxSeverity {
                critical: None,
                high: Some(SeverityCount::Total(30)),
                medium: Some(SeverityCount::Total(0)),
                low: None,
                unknown: None,
            }),
            allow_always:  HashSet::new(),
            deny_always: HashSet::new(),
            ignore_missing_vulnerability_report: false,
            vulnerability_report_namespace: "sbomscanner".to_string(),
            ignore_vex_status: false,
            platform: Some(amd64_linux_platform()),
            cvss_score: Some(settings::CvssScore { threshold: 9.0, max_count: 10 }),
            cve_name: None,
            image_lookup_strategy: ImageLookupStrategy::Digest,
        },
        false
    )]
    #[case::cve_name_match_failed_not_contained_all_cve(
        Some("vulnerabilityreport.yaml".to_owned()),
        {
            let mut cve_set = HashSet::new();
            cve_set.insert("CVE-2021-36159".to_string());
            cve_set.insert("CVE-2021-4321".to_string());
            Settings {
                max_severity: None,
                allow_always: HashSet::new(),
                deny_always: HashSet::new(),
                ignore_missing_vulnerability_report: false,
                vulnerability_report_namespace: "sbomscanner".to_string(),
                ignore_vex_status: false,
                platform: Some(amd64_linux_platform()),
                cvss_score: None,
                cve_name: Some(BaseSettings::ContainsAllOf { values: cve_set }),
                image_lookup_strategy: ImageLookupStrategy::Digest,
            }
        },
        false
    )]
    #[serial]
    fn validate_pod(
        #[case] vulnerability_report_fixture: Option<String>,
        #[case] settings: Settings,
        #[case] accepted: bool,
    ) {
        use std::path::PathBuf;

        let image = "nginx:1.27.1";
        let image_digest = "sha256:1234";
        let resource = pod(image);

        let request = ValidationRequest {
            request: KubernetesAdmissionRequest {
                kind: GroupVersionKind {
                    kind: resource["kind"].as_str().unwrap().to_string(),
                    ..Default::default()
                },
                object: resource,
                ..Default::default()
            },
            settings: settings.clone(),
        };

        let ctx_get_manifest = mock_oci_sdk::get_manifest_context();
        match &settings.image_lookup_strategy {
            ImageLookupStrategy::Digest => {
                ctx_get_manifest.expect().times(1).returning(move |img| {
                    if img != image {
                        Err(anyhow!("it's not searching the expected image"))
                    } else {
                        Ok(OciManifestResponse::Image(Box::new(image_manifest())))
                    }
                });
            }
            ImageLookupStrategy::Tag => {
                ctx_get_manifest.expect().times(0);
            }
        }

        let ctx_get_manifest_digest = mock_oci_sdk::get_manifest_digest_context();

        match &settings.image_lookup_strategy {
            ImageLookupStrategy::Digest => {
                ctx_get_manifest_digest
                    .expect()
                    .times(1)
                    .returning(move |img| {
                        if img != image {
                            Err(anyhow!("it's not searching the expected image"))
                        } else {
                            Ok(ManifestDigestResponse {
                                digest: image_digest.to_string(),
                            })
                        }
                    });
            }
            ImageLookupStrategy::Tag => {
                ctx_get_manifest_digest.expect().times(0);
            }
        }

        let ctx_get_resource = mock_kubernetes_sdk::list_resources_by_namespace_context();
        ctx_get_resource
            .expect::<sbomscanner::storage::v1alpha1::VulnerabilityReport>()
            .times(1)
            .returning(move |req| {
                if req.api_version != "storage.sbomscanner.kubewarden.io/v1alpha1" {
                    return Err(anyhow!("it's not searching the expected API version"));
                }
                if req.kind != "VulnerabilityReport" {
                    return Err(anyhow!("it's not searching the expected Kind"));
                }
                if req.namespace != "sbomscanner" {
                    return Err(anyhow!("it's not searching the expected namespace"));
                }

                match &settings.image_lookup_strategy {
                    ImageLookupStrategy::Digest => {
                        if req.field_selector
                            != Some(format!("imageMetadata.digest={}", image_digest).to_owned())
                        {
                            return Err(anyhow!(
                                "it's not searching the expected VulnerabilityReport by digest"
                            ));
                        }
                    }
                    ImageLookupStrategy::Tag => {
                        let fields = req
                            .field_selector.as_ref()
                            .map(|s| s.to_owned())
                            .unwrap_or_default()
                            .split(',')
                            .map(|s| s.to_string())
                            .collect::<Vec<String>>();
                        let expected_fields = vec![
                            format!("imageMetadata.repository={}", "library/nginx"),
                            format!("imageMetadata.tag={}", "1.27.1"),
                            format!("platform={}", "linux/amd64"),
                        ];
                        for expected in expected_fields {
                            if !fields.contains(&expected) {
                                return Err(anyhow!(
                                    "it's not searching the expected VulnerabilityReport by tag, missing field selector: '{}'",
                                    expected
                                ));
                            }
                        }
                    }
                }

                if let Some(fixture) = vulnerability_report_fixture.clone() {
                    let fixture_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
                        .join("test_data")
                        .join(fixture);
                    let fixture_file = std::fs::File::open(&fixture_path).map_err(|e| {
                        anyhow!("cannot open fixture file '{:?}': {}", fixture_path, e)
                    })?;
                    let vulnerability_report: VulnerabilityReport =
                        serde_yaml::from_reader(fixture_file).expect("cannot parse fixture file");

                    return Ok(k8s_openapi::List {
                        items: vec![vulnerability_report],
                        ..Default::default()
                    });
                };

                Ok(k8s_openapi::List {
                    items: vec![],
                    ..Default::default()
                })
            });

        let response = validate(serde_json::to_vec(&request).unwrap().as_slice()).unwrap();
        let response: ValidationResponse = serde_json::from_slice(&response).unwrap();
        assert_eq!(accepted, response.accepted, "response: {:?}", response);
    }

    #[test]
    #[serial]
    fn get_digest_of_single_arch_image() {
        // Make sure we call get_manifest_context when the image is
        // a single arch one

        let image = "ghcr.io/kubewarden/policy-server:1.29.0";
        let image_digest = "sha256:1234";

        let ctx_get_manifest = mock_oci_sdk::get_manifest_context();
        ctx_get_manifest.expect().times(1).returning(move |img| {
            if img != image {
                Err(anyhow!("it's not searching the expected image"))
            } else {
                Ok(OciManifestResponse::Image(Box::new(image_manifest())))
            }
        });

        let ctx_get_manifest_digest = mock_oci_sdk::get_manifest_digest_context();
        ctx_get_manifest_digest
            .expect()
            .times(1)
            .returning(move |img| {
                if img != image {
                    Err(anyhow!("it's not searching the expected image"))
                } else {
                    Ok(ManifestDigestResponse {
                        digest: image_digest.to_string(),
                    })
                }
            });

        let actual_digest = get_image_digest(image, None).unwrap();
        assert_eq!(actual_digest, image_digest);
    }

    #[rstest]
    #[case::no_platform_specified(
        None,
        Ok("sha256:1782cafde43390b032f960c0fad3def745fac18994ced169003cb56e9a93c028") // amd64/linux is the default
    )]
    #[case::available_platform(
        Some(amd64_linux_platform()),
        Ok("sha256:1782cafde43390b032f960c0fad3def745fac18994ced169003cb56e9a93c028")
    )]
    #[case::arm_linux_platform_missing_variant(
        Some(arm_linux_platform_missing_variant()),
        Err(())
    )]
    #[case::arm_linux_platform_with_variant(
        Some(arm_linux_platform_with_variant()),
        Ok("sha256:ea95bb81dab31807beac6c62824c048b1ee96b408f6097ea9dd0204e380f00b2")
    )]
    #[case::not_available_platform(Some(ppc64_linux_platform()), Err(()))]
    #[serial]
    fn get_digest_of_multi_arch_image(
        #[case] platform: Option<Platform>,
        #[case] expected_digest: Result<&str, ()>,
    ) {
        // Make sure we call get_manifest_digest when the image is
        // a single arch one

        let image = "ghcr.io/kubewarden-sandbox/sbomscanner/test-assets/golang:1.12-alpine";

        let ctx_get_manifest = mock_oci_sdk::get_manifest_context();
        ctx_get_manifest.expect().times(1).returning(move |img| {
            if img != image {
                Err(anyhow!("it's not searching the expected image"))
            } else {
                Ok(OciManifestResponse::ImageIndex(Box::new(image_index())))
            }
        });

        let ctx_get_manifest_digest = mock_oci_sdk::get_manifest_digest_context();
        ctx_get_manifest_digest.expect().times(0);

        let response = get_image_digest(image, platform.as_ref());

        match (response, expected_digest) {
            (Ok(actual), Ok(expected)) => assert_eq!(actual, expected),
            (Err(_), Err(_)) => return,
            (Ok(actual), Err(_)) => panic!("expected error, got digest: {actual}"),
            (Err(e), Ok(expected)) => panic!("expected digest '{expected}', got error: {e}"),
        };
    }

    #[test]
    #[serial]
    fn get_digest_of_image_ref_with_digest() {
        // Make sure we don't call any host capability when the image
        // reference already contains a digest

        let image_digest =
            "sha256:a10b7adfd7b804b4d1e49d74fb6e6211a9f0c825f86fca21b7c23fa0ba540c6d";
        let image = format!("ghcr.io/kubewarden/policy-server:1.29.0@{image_digest}");

        let ctx_get_manifest = mock_oci_sdk::get_manifest_context();
        ctx_get_manifest.expect().times(0);

        let ctx_get_manifest_digest = mock_oci_sdk::get_manifest_digest_context();
        ctx_get_manifest_digest.expect().times(0);

        let actual_digest = get_image_digest(&image, None).unwrap();
        assert_eq!(actual_digest, image_digest);
    }
}
