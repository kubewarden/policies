use std::collections::HashSet;

use criteria_policy_base::settings::BaseSettings;
use oci_spec::image::Platform as OciPlatform;
use serde::{Deserialize, Deserializer, Serialize};

#[derive(Serialize, Deserialize, Debug, Clone, Default, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub(crate) enum ImageLookupStrategy {
    /// Lookup vulnerability reports by image digest (default)
    #[default]
    Digest,
    /// Lookup vulnerability reports by image tag
    Tag,
}

#[derive(Serialize, Debug, Eq, Hash, PartialEq, Clone)]
#[serde(rename_all = "camelCase")]
pub(crate) enum SeverityCount {
    Total(u32),
    TotalWithoutFixes(u32),
}

const SEVERITY_COUNT_MUTUALLY_EXCLUSIVE_ERROR: &str = "cannot specify both 'total' and 'totalWithoutFixes' at the same time - they are mutually exclusive";
const SEVERITY_COUNT_MISSING_ERROR: &str = "must specify either 'total' or 'totalWithoutFixes'";

impl<'de> Deserialize<'de> for SeverityCount {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        use serde::de::{self, MapAccess, Visitor};
        use std::fmt;

        struct SeverityCountVisitor;

        impl<'de> Visitor<'de> for SeverityCountVisitor {
            type Value = SeverityCount;

            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                formatter
                    .write_str("a map with either 'total' or 'totalWithoutFixes', but not both")
            }

            fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
            where
                A: MapAccess<'de>,
            {
                let mut total: Option<u32> = None;
                let mut total_without_fixes: Option<u32> = None;

                while let Some(key) = map.next_key::<String>()? {
                    match key.as_str() {
                        "total" => {
                            if total.is_some() {
                                return Err(de::Error::duplicate_field("total"));
                            }
                            total = Some(map.next_value()?);
                        }
                        "totalWithoutFixes" => {
                            if total_without_fixes.is_some() {
                                return Err(de::Error::duplicate_field("totalWithoutFixes"));
                            }
                            total_without_fixes = Some(map.next_value()?);
                        }
                        _ => {
                            return Err(de::Error::unknown_field(
                                &key,
                                &["total", "totalWithoutFixes"],
                            ));
                        }
                    }
                }

                match (total, total_without_fixes) {
                    (Some(t), None) => Ok(SeverityCount::Total(t)),
                    (None, Some(twf)) => Ok(SeverityCount::TotalWithoutFixes(twf)),
                    (Some(_), Some(_)) => {
                        Err(de::Error::custom(SEVERITY_COUNT_MUTUALLY_EXCLUSIVE_ERROR))
                    }
                    (None, None) => Err(de::Error::custom(SEVERITY_COUNT_MISSING_ERROR)),
                }
            }
        }

        deserializer.deserialize_map(SeverityCountVisitor)
    }
}

#[derive(Serialize, Deserialize, Default, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub(crate) struct MaxSeverity {
    pub critical: Option<SeverityCount>,
    pub high: Option<SeverityCount>,
    pub medium: Option<SeverityCount>,
    pub low: Option<SeverityCount>,
    pub unknown: Option<SeverityCount>,
}

impl MaxSeverity {
    pub fn is_configured(&self) -> bool {
        self.critical.is_some()
            || self.high.is_some()
            || self.medium.is_some()
            || self.low.is_some()
            || self.unknown.is_some()
    }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub(crate) struct CvssScore {
    pub threshold: f32,
    pub max_count: u32,
}

#[derive(Serialize, Deserialize, Debug, Default, Clone)]
#[serde(rename_all = "camelCase")]
pub(crate) struct Platform {
    /// This REQUIRED property specifies the CPU architecture.
    /// Must use values listed in the Go Language document for GOARCH (e.g.: amd64, arm64, s390x).
    pub arch: oci_spec::image::Arch,

    /// This REQUIRED property specifies the operating system.
    /// Must use values listed in the Go Language document for GOOS (e.g.: linux, windows, darwin).
    pub os: oci_spec::image::Os,

    /// This OPTIONAL property specifies the version of the operating system targeted by the referenced blob.
    /// Implementations MAY refuse to use manifests where os.version is not known to work with the host OS version.
    /// Valid values are implementation-defined. e.g. 10.0.14393.1066 on windows.
    pub os_version: Option<String>,

    /// This OPTIONAL property specifies an array of strings, each specifying a mandatory OS feature. When os is windows,
    /// should use the following values:
    ///
    /// - win32k: image requires win32k.sys on the host (Note: win32k.sys is missing on Nano Server)
    ///
    /// When os is not windows, values are implementation-defined and SHOULD be submitted to this specification for standardization.
    pub os_features: Option<Vec<String>>,

    /// This OPTIONAL property specifies the variant of the CPU.
    /// Variant values listed in the [Platform Variants](https://github.com/opencontainers/image-spec/blob/main/image-index.md#platform-variants) table.
    pub variant: Option<String>,
}

/// Converts an OCI Platform to a string format expected by SBOMscanner, which is "os/arch[/variant]".
pub(crate) fn sbomscanner_platform(platform: &OciPlatform) -> String {
    format!(
        "{}/{}{}",
        platform.os(),
        platform.architecture(),
        platform
            .variant()
            .as_ref()
            .map(|v| format!("/{}", v))
            .unwrap_or_default(),
    )
}

impl From<&Platform> for OciPlatform {
    fn from(platform: &Platform) -> Self {
        let mut oci_platform = OciPlatform::default();

        oci_platform.set_architecture(platform.arch.clone());
        oci_platform.set_os(platform.os.clone());
        oci_platform.set_os_version(platform.os_version.clone());
        oci_platform.set_os_features(platform.os_features.clone());
        oci_platform.set_variant(platform.variant.clone());

        oci_platform
    }
}

// Describe the settings your policy expects when
// loaded by the policy server.
#[derive(Serialize, Deserialize, Debug, Default, Clone)]
#[serde(default, rename_all = "camelCase")]
pub(crate) struct Settings {
    pub max_severity: Option<MaxSeverity>,
    pub allow_always: HashSet<String>,
    pub deny_always: HashSet<String>,
    pub ignore_missing_vulnerability_report: bool,
    pub vulnerability_report_namespace: String,
    pub ignore_vex_status: bool,
    pub cvss_score: Option<CvssScore>,

    /// The platform to be checked when a multi architecture image is found.
    /// If not provided, the policy will use the same platform as the node that runs the Policy
    /// Server.
    pub platform: Option<Platform>,

    /// This OPTIONAL property specifies the match criteria for the CVE name.
    pub cve_name: Option<BaseSettings>,

    /// Specifies how to lookup vulnerability reports for images.
    /// - Digest: lookup by image digest (default, recommended for security)
    /// - Tag: lookup by image tag
    pub image_lookup_strategy: ImageLookupStrategy,
}

impl kubewarden_policy_sdk::settings::Validatable for Settings {
    fn validate(&self) -> Result<(), String> {
        if self.vulnerability_report_namespace.is_empty() {
            return Err("vulnerabilityReportNamespace cannot be empty".to_string());
        }

        let allowed_and_denied = self
            .allow_always
            .intersection(&self.deny_always)
            .collect::<Vec<_>>();
        if !allowed_and_denied.is_empty() {
            return Err(format!(
                "The following CVEs are both allowed and denied: {allowed_and_denied:?}"
            ));
        }

        if let Some(cvss_score) = &self.cvss_score
            && (cvss_score.threshold < 0.0 || cvss_score.threshold > 10.0)
        {
            return Err(format!(
                "cvssScore.threshold must be between 0.0 and 10.0, got {}",
                cvss_score.threshold
            ));
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use kubewarden_policy_sdk::settings::Validatable;
    use rstest::rstest;
    use serde_json::json;

    #[test]
    fn validate_empty_settings() {
        let settings = Settings::default();

        let validation_result = settings.validate();
        assert!(validation_result.is_err());

        let err_msg = validation_result.unwrap_err();
        assert!(err_msg.contains("vulnerabilityReportNamespace cannot be empty"));

        assert!(settings.validate().is_err());
    }

    #[test]
    fn validate_allowed_and_denied_cves() {
        let settings = Settings {
            allow_always: vec!["CVE-2021-4321".to_string(), "CVE-2021-1234".to_string()]
                .into_iter()
                .collect(),
            deny_always: vec!["CVE-2021-1234".to_string()].into_iter().collect(),
            vulnerability_report_namespace: "default".to_string(),
            ..Default::default()
        };

        let validation_result = settings.validate();
        assert!(validation_result.is_err());
        let err_msg = validation_result.unwrap_err();
        assert!(err_msg.contains("The following CVEs are both allowed and denied"));
        assert!(err_msg.contains("CVE-2021-1234"));
    }

    #[test]
    fn cannot_define_severity_values_with_total_and_total_without_fixes_at_the_same_time() {
        let settings_raw = json!(
            {
                "maxSeverity": {
                    "critical": {
                        "total": 1,
                        "totalWithoutFixes": 2
                    }
                },
                "scanReportNamespace": "default"
            }
        );

        let settings = serde_json::from_value::<Settings>(settings_raw);
        let err_msg = settings.unwrap_err().to_string();
        assert!(
            err_msg.contains(SEVERITY_COUNT_MUTUALLY_EXCLUSIVE_ERROR),
            "Expected user-friendly error message, got: {}",
            err_msg
        );
    }

    #[test]
    fn can_define_severity_values_with_total_only() {
        let settings_raw = json!(
            {
                "maxSeverity": {
                    "critical": {
                        "total": 10
                    }
                },
                "vulnerabilityReportNamespace": "default"
            }
        );

        let settings = serde_json::from_value::<Settings>(settings_raw);
        assert!(settings.is_ok());
        let settings = settings.unwrap();
        assert!(matches!(
            settings.max_severity.unwrap().critical,
            Some(SeverityCount::Total(10))
        ));
    }

    #[test]
    fn can_define_severity_values_with_total_without_fixes_only() {
        let settings_raw = json!(
            {
                "maxSeverity": {
                    "critical": {
                        "totalWithoutFixes": 5
                    }
                },
                "vulnerabilityReportNamespace": "default"
            }
        );

        let settings = serde_json::from_value::<Settings>(settings_raw);
        assert!(settings.is_ok());
        let settings = settings.unwrap();
        assert!(matches!(
            settings.max_severity.unwrap().critical,
            Some(SeverityCount::TotalWithoutFixes(5))
        ));
    }

    #[test]
    fn cannot_define_severity_values_without_total_or_total_without_fixes() {
        let settings_raw = json!(
            {
                "maxSeverity": {
                    "critical": {}
                },
                "vulnerabilityReportNamespace": "default"
            }
        );

        let settings = serde_json::from_value::<Settings>(settings_raw);
        assert!(settings.is_err());
        let err_msg = settings.unwrap_err().to_string();
        assert!(
            err_msg.contains(SEVERITY_COUNT_MISSING_ERROR),
            "Expected error message '{}', got: '{}'",
            SEVERITY_COUNT_MISSING_ERROR,
            err_msg
        );
    }

    #[test]
    fn cannot_define_severity_values_with_total_specified_twice() {
        // Note: serde_json doesn't allow duplicate keys in json! macro,
        // so we use a raw JSON string to simulate the duplicate field scenario
        let settings_raw = r#"{
            "maxSeverity": {
                "critical": {
                    "total": 5,
                    "total": 10
                }
            },
            "vulnerabilityReportNamespace": "default"
        }"#;

        let settings = serde_json::from_str::<Settings>(settings_raw);
        assert!(settings.is_err());
        let err_msg = settings.unwrap_err().to_string();
        assert!(
            err_msg.contains("duplicate field `total`"),
            "Expected duplicate field error, got: {}",
            err_msg
        );
    }

    #[test]
    fn image_lookup_strategy_defaults_to_digest() {
        let settings_raw = json!(
            {
                "vulnerabilityReportNamespace": "default"
            }
        );

        let settings = serde_json::from_value::<Settings>(settings_raw);
        assert!(settings.is_ok());
        let settings = settings.unwrap();
        assert_eq!(settings.image_lookup_strategy, ImageLookupStrategy::Digest);
    }

    #[test]
    fn image_lookup_strategy_can_be_set_to_tag() {
        let settings_raw = json!(
            {
                "vulnerabilityReportNamespace": "default",
                "imageLookupStrategy": "tag"
            }
        );

        let settings = serde_json::from_value::<Settings>(settings_raw);
        assert!(settings.is_ok());
        let settings = settings.unwrap();
        assert_eq!(settings.image_lookup_strategy, ImageLookupStrategy::Tag);
    }

    #[test]
    fn image_lookup_strategy_can_be_set_to_digest() {
        let settings_raw = json!(
            {
                "vulnerabilityReportNamespace": "default",
                "imageLookupStrategy": "digest"
            }
        );

        let settings = serde_json::from_value::<Settings>(settings_raw);
        assert!(settings.is_ok());
        let settings = settings.unwrap();
        assert_eq!(settings.image_lookup_strategy, ImageLookupStrategy::Digest);
    }

    #[test]
    fn validate_cvss_score() {
        let settings_raw = json!(
            {
                "cvssScore": {
                    "threshold": 7,
                }
            }
        );

        let settings = serde_json::from_value::<Settings>(settings_raw);
        assert!(
            settings
                .unwrap_err()
                .to_string()
                .contains("missing field `maxCount`")
        );
    }

    #[test]
    fn validate_cvss_score_threshold_out_of_range() {
        let settings = Settings {
            vulnerability_report_namespace: "default".to_string(),
            cvss_score: Some(CvssScore {
                threshold: 11.0,
                max_count: 0,
            }),
            ..Default::default()
        };

        let validation_result = settings.validate();
        assert!(
            validation_result
                .unwrap_err()
                .to_string()
                .contains("cvssScore.threshold must be between 0.0 and 10.0, got 11")
        );
    }

    #[rstest]
    #[case::linux_amd64(
        Platform {
            os: oci_spec::image::Os::Linux,
            arch: oci_spec::image::Arch::Amd64,
            variant: None,
            ..Default::default()
        },
        "linux/amd64"
    )]
    #[case::linux_arm64_v7(
        Platform {
            os: oci_spec::image::Os::Linux,
            arch: oci_spec::image::Arch::ARM64,
            variant: Some("v7".to_string()),
            ..Default::default()
        },
        "linux/arm64/v7"
    )]
    #[case::ignore_os_version_and_features(
        Platform {
            os: oci_spec::image::Os::Linux,
            arch: oci_spec::image::Arch::Amd64,
            os_version: Some("5.10".to_string()),
            os_features: Some(vec!["sse4".to_string()]),
            ..Default::default()
        },
        "linux/amd64"
    )]
    fn convert_platform_to_sbomscanner_format(#[case] platform: Platform, #[case] expected: &str) {
        let oci_platform: OciPlatform = (&platform).into();
        let sbomscanner_platform = sbomscanner_platform(&oci_platform);
        assert_eq!(&sbomscanner_platform, expected);
    }
}
